1#Choisir la ou les bonnes réponses#Quelle est la différence entre une erreur et une exception ?#Dans la plupart des cas, on peut récupérer d’une erreur alors qu’une exception est une condition irrécupérable_false#Dans la plupart des cas, on peut récupérer d’une exception alors qu’une erreur est une condition irrécupérable_true#Une erreur et une exception héritent de Error et donc ne sont pas différentes_false#Une erreur et une exception héritent de Exception et donc ne sont pas différentes_false
2#Choisir la ou les bonnes réponses#Si une classe hérite déjà d’une classe et je veux qu’une instance de cette classe soit jetée (thrown) comme un objet exception, que doit-on faire #On peut ajouter la sous-classe Exception en séparant la classe mère héritée par une virgule_false#On ne peut rien faire car Java ne permet pas l’héritage multiple_true#Toutes les réponses ci-dessus_false
3#Choisir la ou les bonnes réponses#Le BorderLayout est un gestionnaire de placement qui :#contient 5 régions de placement_true#est le gestionnaire par défaut d’un JFrame_true#place les composants selon un flot de gauche à droite sur le JPanel_false#Toutes les réponses ci-dessus sont correctes_false
4#Choisir la ou les bonnes réponses#On peut créer une exception personnalisée en :#Créant la classe qui hérite de Error_false#Créant la classe qui hérite de la classe Exception_true#Créant la classe qui hérite d’une sous-classe de Exception_true#Toutes les réponses ci-dessus_false
5#Choisir la ou les bonnes réponses#Le FlowLayout est un gestionnaire de placement : #qui est le gestionnaire par défaut d’un JFrame_false#qui peut être une des régions d’un BorderLayout_true#qui peut avoir une des régions basées sur un GridLayout_false#Toutes les réponses ci-dessus sont correctes_false
6#Choisir la ou les bonnes réponses#Une exception contrôlée doit être prise en charge dans votre application#Pas vraiment, on peut choisir de ne pas la gérer_false#Oui, il faut qu’on la gère dans notre code_true#Non, on ne doit pas gérer ce genre d’Exception_false#Toutes les réponses ci-dessus sont correctes._false
7#Choisir la ou les bonnes réponses#La différence entre throws et throw dans la gestion des exceptions est :#throws est utilisé dans le corps de la méthode pour lever une exception alors que throw est utilisé dans l’entête de la méthode pour indiquer que la méthode peut jeter cette exception_false#throw est utilisé dans le corps de la méthode pour lever une exception alors que throws est utilisé dans l’entête de la méthode pour indiquer que la méthode peut jeter cette exception_true#Les deux sont utilisées dans le corps de la méthode dans le cas où plusieurs exceptions risquent d’être levées_false#Toutes les réponses ci-dessus sont correctes_false
8#Choisir la ou les bonnes réponses#Une interface peut disposer d’un nombre limité d’attributs#Vrai_false#Faux_true
9#Choisir la ou les bonnes réponses#Une classe abstract peut hériter d’une interface#Vrai_false#Faux_true#Vrai si la classe n’a pas hérité d’une autre classe_false
10#Choisir la ou les bonnes réponses#Une classe enfant hérite du constructeur de son parent#Vrai_false#Faux_true#Seul le constructeur par défaut du parent peut être hérité_false
14#Choisir la ou les bonnes réponses#Dans une utilisation de lecture de fichier, il est important d’utiliser BufferedReader avec FileReader#Oui, parcequ’on va bénéficier des méthodes spécifique de BufferedReader( lecture par ligne par exemple)_true#Non, le FileReader ne peut pas être utilisé avec le BufferedReader_false#Il n’y a aucun interet d’utiliser le BufferedReader_false
15#Choisir la ou les bonnes réponses#Une classe Java peut hériter de plusieurs classes#Faux_true#Vrai_false
17#Choisir la ou les bonnes réponses#Pour appeler la méthode nomMethode() d’une classe parent à partir de la classe enfant, on utilise le mot clé :#base.nomMethode()_false#super.nomMethode()_true#override.nomMethode()_false#virtual.nomMethode()_false
